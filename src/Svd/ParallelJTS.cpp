#include <atomic>

#include "Svd/ParallelJTS.hpp"
#include "Utils/Logger.hpp"
#include "Utils/UtilityFunctions.hpp"

using namespace GAMM;

void ParallelJTS::startSvd(Matrix matrix) {
  INTELLI_ASSERT(matrix.rows() == matrix.cols(),
                 "Only square matrices supported");

  b = std::move(matrix);

  delta = options.tol * b.squaredNorm();
  v = Matrix::Identity(b.rows(), b.cols());

  p1.resize(nColumnPairs());
  p2.resize(nColumnPairs());
  q.resize(npivots());

  std::vector<std::pair<std::mutex, size_t>> temp{options.t};
  sortLocks.swap(temp);

  pToUse = UtilityFunctions::trailingZeros(
               UtilityFunctions::nextPowerOfTwo(options.t)) %
           2;
}

bool ParallelJTS::svdStep() { return svdStep(1); }
bool ParallelJTS::svdStep(size_t nsteps) {
  BS::multi_future<void> tasks(options.t - 1);

  for (size_t i = 1; i < options.t; ++i) {
    tasks[i] =
        options.pool->submit([this, nsteps, i]() { workerTask(i, nsteps); });
  }
  auto result = workerTask(0, nsteps);
  tasks.get();

  return result;
}

void ParallelJTS::finishSvd() {
  size_t n = b.rows();

  sv.resize(n);
  for (size_t i = 0; i < n; ++i) {
    auto &value = sv.diagonal()[i];
    value = b.col(i).norm();
    if (value < options.tol) {
      value = 0.0;
      b.col(i) *= 0;
    } else {
      b.col(i) /= value;
    }
  }

  sortSingularValues();
}

bool ParallelJTS::workerTask(size_t workerId, size_t nsteps) {
  // Do not go past maxSweeps specified by the user
  size_t maxIters = std::min(iterNumber + nsteps, options.maxSweeps);

  for (; iterNumber < maxIters; ++iterNumber) {
    // ============  PHASE 1  ============
    // Generate columns on which rotations will be applied
    workerTaskPhase1(workerId);

    // Wait for MAIN_WORKER to sort and (possibly) set exit condition
    barrier.arrive_and_wait();

    // Barrier takes care of synchronisation, so relaxed ordering is fine
    if (counter.load(std::memory_order_relaxed) == COMPLETED) {
      return true;
    }
    // ===================================

    // ============  PHASE 2  ============
    // Generate rotations based on the top 1/tau fraction of column-pairs (in
    // parallel).
    workerTaskPhase2(workerId);
    // ===================================

    // Wait for all threads to finish generating the Jacobi rotations.
    barrier.arrive_and_wait();

    // ============  PHASE 3  ============
    // Apply Jacobi rotations
    // Non parallel -- only MAIN_WORKER applies all rotations
    workerTaskPhase3(workerId);
    // ===================================
  }

  return iterNumber == options.maxSweeps;
}

void ParallelJTS::workerTaskPhase1(size_t workerId) {
  size_t n = b.cols();
  auto t = options.t;

  // The start index of the part of p to be written to by this thread, and
  // the number of elements to write
  auto totalNouterIters = n / 2;
  auto nInnerIters = n + (n % 2) - 1;

  auto [outerIterStartI, nOuterIters] =
      UtilityFunctions::unevenDivide(workerId, totalNouterIters, t);

  auto startI = outerIterStartI * nInnerIters;
  auto nelements = nOuterIters * nInnerIters;

  for (auto j1 = workerId, i = startI; j1 < totalNouterIters; j1 += t, ++i) {
    auto k1 = j1 + 1;

    auto j2 = n - j1 - 1 - (n % 2);
    auto k2 = j2 + 1;

    // ------------ PHASE 1.1 ------------
    // Generate all the possible column pairs (in parallel). Then sort each
    // subset of column-pairs generated by each thread (in parallel).
    for (auto k = k1, j = j1; k < n; k++) {
      auto d = b.col(j).dot(b.col(k));
      std::construct_at(&p1[i], j, k, d);
    }

    for (auto k = k2, j = j2; k < n; k++) {
      auto d = b.col(j).dot(b.col(k));
      std::construct_at(&p1[i], j, k, d);
    }
  }

  std::sort(p1.begin() + startI, p1.begin() + startI + nelements);

  {
    auto &sortLock = sortLocks[workerId];
    const std::lock_guard<std::mutex> ourGuard{sortLock.first};

    sortLock.second = nelements;

    // Wait for all threads to fill p and to have their own locks
    barrier.arrive_and_wait();

    // ------------ PHASE 1.2 ------------
    // Merge sorted subsets of column-pairs (in parallel). The main worker also
    // sets a flag to indicate completion.
    auto nruns = UtilityFunctions::trailingZeros(
        workerId | UtilityFunctions::nextPowerOfTwo(t));

    auto curP = p1.begin() + startI;
    auto mergeToP = p2.begin() + startI;

    for (size_t i = 0; i < nruns; ++i) {
      auto otherId = workerId + (2 << i);
      if (otherId >= t) {
        break;
      }

      auto &otherLock = sortLocks[otherId];
      const std::lock_guard<std::mutex> otherGuard{otherLock.first};

      // clang-format off
      std::merge(
          curP            , curP + sortLock.second, // Our slice of p
          curP + nelements, curP + sortLock.second + otherLock.second, // Other's slice of p
          mergeToP
      );

      std::swap(curP, mergeToP);
      sortLock.second += otherLock.second;
      // clang-format on
    }
  }

  if (workerId == 0) {
    auto hasCompleted = (p()[0].d < delta) ? COMPLETED : 0;
    counter.store(hasCompleted, std::memory_order_relaxed);
  }
}

void ParallelJTS::workerTaskPhase2(size_t workerId) {
  for (auto i = workerId; i < npivots(); i += options.t) {
    std::construct_at(&q[i], p()[i], b);
  }
}

void ParallelJTS::workerTaskPhase3(size_t workerId) {
  // Only main worker performs any operations in this phase
  if (workerId != 0) {
    return;
  }

  for (auto rotation : q) {
    rotation.applyTo(b);
    rotation.applyTo(v);
  }
}
